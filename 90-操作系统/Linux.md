---
banner: "https://api.dujin.org/bing/1920.php"
cssclass: noyaml,noscroll,myhome
obsidianUIMode: preview
banner_x: 0.5
banner_y: 0.5
---

#Linux #操作系统

# Linux 操作系统概述
## 历史
Linux：Unix-->minix-->Linux
## 特点
Linux 操作系统是一个==免费、自由、开放==的操作系统，它拥有如下一些特点：
+ 完全免费
+ 高效安全稳定
+ 支持多种硬件平台
+ 友好的用户界面
+ 强大的网络功能
+ 支持多任务、多用户

## 开源和免费
>开源和免费的关系：
>开源的也可能不是免费的

+ 使用的自由
绝大多数开源软件免费
+ 研究的自由
可以获得软件源代码
+ 散步及改良的自由
可以自由传播、改良甚至销售

## Linux 的版本

> Linux 的版本分为内核版本和发行版本

+ 内核版本是指在 Linus 领导下的内核小组开发维护的系统内核的版本号
+ 发行版本是 Linux 核心再加上外围的实用程序组成的一个大软件包而已，一些组织和公司根据自己发行版的不同而自定的。
### Linux 内核版本
Linux 内核官网：[The Linux Kernel Archives](https://www.kernel.org/)
版本号：“主版本号. 次版本号. 修正号”
主版本号和次版本号标志着重要的功能变动。

### Linux 发行版本

Ubuntu
centos
Debian
Redhat

> centos 是 Redhat 系列的 Linux

## Linux 与 Windows 的不同

+ Linux 严格区分大小写
+ Linux 中所有内容以文件形式保存，包括硬件
+ Linux 不靠扩展名区分文件类型
	+ 无扩展名的概念，以文件权限来区分文件类型
	+ 约定成俗的一部分名字用来给管理员区分文件；并不是必须的
+ Windows 下的程序不能直接在 Linux 系统下运行

## Linux 的字符界面
优势：
1. 字符界面占用的系统资源更少
2. 字符界面减少了出错、被攻击的可能性

> 使用字符界面占用系统资源更少，让操作系统更稳定

## Linux 操作系统的安装

### 系统分区
磁盘分区是使用==分区编辑器==在==磁盘==上划分几个==逻辑部分==。碟片一旦划分成数个分区，不同类的目录与文件可以存储进不同的分区。

主分区：最多只能有 4 个
扩展分区：==最多只能有 1 个==，主分区加扩展分区最多有四个。==不能写入数据==，只能包含逻辑分区
逻辑分区：组成扩展分区

### 格式化

格式化又称逻辑格式化，它是指根据用户选定的文件系统（如 FAT16、FAT32、NTFS、EXT2、EXT3、EXT4 等），在磁盘的特定区域写入特定数据，在分区中划出一片用于存放文件分配表、目录等用于文件管理的磁盘空间。

### 分区表示
系统分区步骤：分区-->格式化（小分区打隔断）-->起名-->分配盘符-->挂载（盘符和分区连接在一起）

### 挂载
+ 挂载（mounting）是指由操作系统使一个存储设备（诸如硬盘、CD-ROM 或共享资源）上的计算机文件和目录可供用户通过计算机的文件系统访问的一个过程。
+ 在 Linux 操作系统中，挂载是一个非常重要的功能，使用非常频繁。它指将一个设备（通常是存储设备）挂接到一个已存在的目录上。
+ Linux 操作系统将所有的设备都看作文件，它将整个计算机的资源都整合成一个大的文件目录。
+ 我们要访问存储设备中的文件，必须将文件所在的分区挂载到一个已存在的目录上，然后通过访问这个目录来访问存储设备。
+ 分配盘符的过程就是挂载（文件和分区链接起来）。盘符就是挂载点。
+ ==必须有的分区==：/根分区 swap 交换分区（虚拟分区）
+ ==建议必须以后的==：boot 启动分区

### 目录
+ ==/swap (必须有)==：swap 分区通常被称为==交换分区==，这是一块特殊的硬盘空间，即当实际内存不够用的时候，操作系统会从内存中取出一部分暂时不用的数据，放在交换区中，从而为当前运行的程序腾出足够的内存空间。
+ /bin:/user/bin: 可执行==二进制文件==的目录，如常用的命令 ls、tar、mv、cat 等。
+ ==/boot==：放置==Linux 系统启动==时用到的一些文件。/boot/vmlinuz 为 Linux 的内核文件，以及/boot/gurb。建议单独分区，分区大小 100M 即可。
+ /dev: 存放 Linux 系统下的==设备文件==，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 mount/dev/cdrom/mnt。
+ ==/root：系统管理员 root 的家目录，系统第一个启动的分区为/，所以最好将/root 和/放置在一个分区下。==
+ ==/home: 系统默认的用户目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，~edu 表示用户 edu 的家目录。建议单独分区，并设置较大的磁盘空间，方便用户存放数据。==
+ /lib：/usr/lib:/usr/local/lib: 系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助，比较重要的目录为/lib/modules。
+ /lost+found：系统异常产生错误时，会将一些遗失的片段放置在此目录下，通常这个目录会自动出现在装置目录下。如加载硬盘于/disk 中，此目录下就会自动产生目录/disk/lost+found
+ /mnt:/media: 光盘默认挂载点，通常光盘挂载于/mnt/cdrom 下，也不一定，可以选择任意位置进行挂载。
+ /opt: 给主机额外安装软件所摆放的目录。如：FC4 使用的 Fedora 社群开发软件，如果想要自行安装新的 KDE 桌面软件，可以将该软件安装在该目录下。以前的 Linux 系统中，习惯放置在/usr/local 目录下。
+ /proc: 此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放在内存中，所以不占用磁盘空间，比较重要的目录有 /proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/等。
+ /sbin:/usr/sbin:/usr/local/sbin: 放置==系统管理员使用的可执行命令==，如 fdisk、shutdown、mount 等。与/bin 不同的是，这几个目录是给系统管理员 root 使用的命令，一般用户只能“查看”而不能设置和使用。
+ /tmp：一般用户或正在执行的程序==临时存放文件==的目录，任何人都可以访问，重要数据不可放置在此目录下
+ /srv：服务启动之后需要访问的==数据目录==，如 www服务需要访问的网页数据存放在/srv/www内
+ /usr：==应用程序存放目录==，/usr/bin 存放应用程序，/usr/share 存放共享数据，/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local：存放软件升级包，/usr/share/man/man1/ls.1. gz 的内容建议单独分区，设置较大的磁盘空间。
+ /var: 放置系统执行过程中==经常变化的文件==，如随时更改的日志文件/var/log，/var/log/message: 所有的登录文件存放目录，/var/spool/mail: 邮件存放的目录，/var/run: 程序或服务启动后，其 PID 存放在该目录下。建议单独分区，设置较大的磁盘空间。
+ /etc: 系统==配置文件==存放目录，不建议在此目录下存放可执行文件，重要的配置文件有/etc/inittab、/etc/fstab、/etc/init. d、/etc/X11、/etc/xinetd. d 修改配置文件之前记得备份。
总结：
常用目录及作用
+ `/` 根目录
+ `/bin` 命令保存目录
+ `/boot` 启用目录，启动相关文件
+ `/dev` 设备文件保存目录
+ `/etc` 配置文件保存目录
+ `/home` 普通用户的家目录
+ `/temp` 临时文件目录
+ `/mnt` 系统挂载目录

## 例题
1. Linux 中主分区最多==4==个, 最少==1===个
2. Linux 中扩展分区最多==1==个，最少==0==个
3. 第一个逻辑分区的标识符为==5==
4. Linux 系统安装时，必须安装的两个分区是：==/和 swap==
5. 存放普通用户数据的目录为：home
6. 存放与 Linux 系统启动有关的程序的目录为：boot
7. 在 Linux 操作系统中把外部设备当做文件统一管理，外部设备文件通常放在==/dev==目录中
8. 常用的分区类型：主分区、扩展分区、逻辑分区
# 常用命令
推荐：[Linux 命令大全 | 菜鸟教程](https://www.runoob.com/linux/linux-command-manual.html)
## 命令基本格式
`[root@localhost ~] #`

[]：这是提示符的分隔符号，没有特殊含义。
root：显示的是当前的登录用户。
@：分隔符号，没有特殊含义。
localhost：当前系统的简写主机名（完整主机名是 localhost. localdomain）。
~：代表用户当前所在的目录的最后一级目录。
最后#：表示命令提示符。超级用户是#，普通用户是$。
==提示：~为当前用户的家目录。==

命令格式：`命令 [选项] [参数]`
==注意：个别命令使用不遵循此格式，当有多个选项是，可以写在一起==

## 查询目录中的内容
`ls [选项] [文件或目录]`
选项：
+ -a 显示所有文件，包括==隐藏文件==
+ -l 显示详细信息，查看权限
+ -d 查看目录属性
+ -h 人性化显示文件大小
+ -i 显示 inode

![](https://obsidian-picture.oss-cn-qingdao.aliyuncs.com/my-img/Linux1.png)
说明：
第一列：权限。
第二列：引用计数。
该参数没有太大作用，而且引用计数对于文件和目录是有区别的。
文件的引用计数代表该文件的硬链接个数。
目录的引用计数代表该目录有多少个一级子目录。
也就是说，如果是文件就代表该文件的硬链接个数，如果是目录代表该目录有多少个一级子目录。
第三列：所有者，也就是这个文件属于哪个用户。默认所有者是文件的建立用户。
第四列：所属组。默认所属组是文件建立用户的有效组，一般情况下就是建立用户的所在组。
为什么一个文件要分所有者和所属组呢？
是为了分配权限的时候，指定权限方便分配。
第五列：文件大小。默认单位是字节（byte）。
第六列：文件修改时间。
文件状态修改时间（访问时间）或文件数据修改时间都会更改这个时间，哪个时间最后，显示哪个时间。注意这个时间不是文件的创建时间。
第七列：文件名。
### 文件类型和权限
d：目录文件
-：普通文件
p：管理文件
l：链接文件
b：块设备文件
c：字符设备文件
s：套接字文件

权限：
读：（r）对应 4
写：（w）对应 2
执行：（x）对应 1
第二段表示所有者权限，第三段表示组用户权限，第四段表示其他用户组权限
## 帮助命令
`man 命令`
例如：`man ls`
查看 ls 的帮助
`命令 --help` 或 `help 命令`
## 目录和文件处理命令
### 建立目录
`mkdir [选项] [目录名]`
选项：
+ -p 递归创建
+ -m 权限
### 建立文件
`touch [文件名]`
==注意：如果文件不存在，使用 touch 命令默认创建一个空文件；如果文件存在则更新 atime，mtime，ctime 为当前时间==
+ -a 更新 atime 和 ctime 为当前时间
### 切换所在目录
`cd`
简化操作：
cd ~ 进入当前用户的家目录
cd - 进入上次目录
cd .. 进入上一级目录
cd . 进入当前目录
cd [/]目录名进入指定目录
### 查询所在目录位置
`pwd`
### 删除空目录
`rmdir [目录名]`
### 删除文件或目录
`rm`
选项：
+ -r：删除目录
+ -f：强制删除
### 复制
`cp [选项] [原文件或目录] [目标目录]`
选项：
+ -r 复制目录
+ -p 连带文件复制属性
+ -d 若原文件是链接文件，则复制链接属性
+ -a 相当于 pdr
### 剪切或改名
`mv [原文件或目录] [目标目录]`
### 修改文件权限
`chmod`
字母法：chmod （u g o a）（+ - =）（r w x）文件名
例：chmod u+rwx，g+rwx，o+rwx filename
数字法：chmod 数字组合文件名
例：chmod 777 文件名
### 链接
`ln`
使用方法：`ln -s [原文件] [目标文件]`
功能：生成链接文件
选项：-s 创建软链接
硬链接特征：
1. 拥有相同的 i 节点和存储 block 块，可以看做是同一文件
2. 可通过 i 节点识别
3. 不能跨分区
4. 不能针对目录使用
5. 不太常用（比较隐蔽，限制比较多）

软链接特征：
1. 类似 Windows 快捷方式
2. 软链接拥有自己的 i 节点和 block 块，但是数据块中只保存原文件的文件名和 i 节点，并没有实际的文件数据
3. `lrwxrwxrwx` l 表示软连接，文件权限是 rwxrwxrwx
4. 修改任意文件，另一个都改变
5. 删除原文件，软链接不能使用
### 文件搜索
1. `find`
使用方法：
+ `find [搜索范围] [搜索文件]`
+ 搜索文件
+ find 目录-name 
+ 避免大范围搜索，会非常耗费系统资源
+ find 是在系统当中搜索符合条件的文件名。如果需要匹配，使用通配符匹配，通配符是完全匹配
通配符：

| 符号     | 含义                                                             |
| -------- | ---------------------------------------------------------------- |
| `*`      | 匹配任意长度的任意字符，可以是 0 个                                |
| `?`      | 匹配任意单个字符，必须是 1 个                                      |
| `[]`     | 匹配指定字符范围内的任意单个字符                                 |
| `[abcd]` | 匹配 abcd 中任何一个字符                                           |
| `[a-z]`  | 表示范围 a 到 z，表示范围的意思，[]匹配中括号中任意一个字符 ls fie 0 |
| `[!abcd]`         |或 `[^abcd]` 表示非，表示不匹配括号里面的任何一个字符                                                                  |
2. `locate`
使用方法：`locate 文件名`
在后台数据块中按文件名搜索，搜索速度更快
==速度快==
updatedb 更新数据库
3. `whereis`
搜索命令位置和帮助文档位置的命令
使用方法：`whereis 命令名`
搜索命令所在路径及帮助文档所在位置
4. `which`
搜索命令的命令
使用方法：`which 命令名`
搜索命令别名和命令位置
5. `grep`
使用方法：`grep [选项] 字符串 文件名`
在文件当中匹配符合条件的字符串
选项：-i 忽略大小写；-v 排除指定字符串

> find 命令：在系统当中搜索符合条件的==文件名==，如果需要匹配，使用通配符匹配，通配符是完全匹配
> grep 命令：在文件中搜索符合条件的==字符串==，如果需要匹配，使用正则表达式进行匹配，正则表达式时包含匹配

## 打包与压缩命令
### 压缩与解压缩
语法：`zip 压缩文件名 源文件`
压缩文件
语法：`zip -r 压缩目录名 源目录`
压缩目录
语法：`unzip 压缩文件`
解压. zip 文件
语法：`gzip 源文件`
压缩为. gz 格式的压缩文件，源文件会消失
语法：`gzip -c 源文件 > 压缩文件`
压缩为. gz 格式，源文件保留
语法：`gzip -r 目录`
压缩目录下所有的子文件，但是不能压缩目录
语法：`gzip -d 压缩文件`
解压缩文件
语法：`gunzip 压缩文件`
解压缩文件
语法：`bzip2 源文件`
压缩为. bz2 格式，不保留源文件
语法：`bzip2 -k 源文件`
压缩之后保留源文件
语法：`bzip2 -d 压缩文件`
解压缩
==注意：bzip2 命令不能压缩目录==
### 打包
打包是指将一大堆文件或目录什么的变成一个总的文件，压缩则是将一个大的文件通过一些压缩算法变成一个小文件
语法：`tar -cvf 打包文件名 源文件`
选项：
-c 打包
-v 显示过程
-f 指定打包后的文件名
语法：`tar -xvf 打包文件名`
选项：
-x 解打包
语法：`tar -zcvf 压缩包名.tar.gz 源文件`
选项：
-z 压缩为. tar. gz 格式
语法：`tar -jcvf 压缩包名.tar.bz2 源文件`
选项：
-j 压缩为. tar. bz2 格式
语法：`tar -jxvf 压缩包名.tar.bz2`
选项：
-x 解压缩. tar. bz2 格式
## 开机与重启
+ 关机
语法：`shutdown [选项] 时间`
选项：
-c 取消前一个关机命令
-h 关机
-r 重启
语法：`halt`
语法：`poweroff`
语法：`init 0`
+ 重启
语法：`reboot`
语法：`init6`
+ 退出登录
语法：`exit`
## 其他常用命令
+ 查看登录用户信息：`w 用户名`
信息解释：
1. `LOGIN@` 登录时间
2. `IDLE` 用户闲置时间
3. `JCPU` 和该终端连接的所有进程占用的 CPU 运算时间。这个时间里并不包括过去的后台作业时间，但是包括当前正在运行的后台作业所占用的时间
4. `PCPU` 当前进程所占用的 CPU 运算时间
5. `WHAT` 当前正在运行的命令
+ 查看登录用户信息：`who 用户名`
命令输出：`-H` 或 `--heading`，显示各栏位的标题信息列；`-q` 或 `--count`，只显示登入系统的账号名称和总人数
+ 查询当前登录和过去登录的用户信息：`last`
默认是读取/var/log/wtmp 文件数据
+ 查看所有用户的最后一次登录时间：`lastlog`
默认是读取/var/log/lastlog 文件内容
## vim
详见：[vim](vim.md)
## 文件操作
### 查阅
1. 语法：`cat 参数 文件名`
显示或把多个文本文件连接起来
参数：
-n 由 1 开始对所有输出编号
-b 空白行不编号
-s 空白行合并
+ 原样显示，而且显示所有内容
+ 缺点：如果文件内容很多，只能看到最后一点内容
创建文件：`cat > b.txt`创建`b.txt`文件
合并文件：`cat b.txt c.txt > bc.txt` 合并 b. txt 和 c. txt 文件，并输出为 bc. txt
2. 语法：`more 参数 文件名`
类似 cat，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，b 上一页显示
参数：
+n 从第 n 行开始显示
-n 每页n行
-s 空行压缩
-u 去下划线
3. 语法：`less 参数 文件名`
与 more 用法相同，显示从文件最后开始，可以向前向后翻阅，q 退出
4. 语法：`head 参数 文件名`
用于查看文件的开头部分的内容，有一个常用的参数
参数：
-n 用于显示行数，默认为 10，即显示 10 行的内容
5. 语法：`tail 参数 文件名`
用于查看文件的结尾部分的内容
### 创建文件
1. 语法：`touch` 
用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件
2. 语法：`cp`
复制并创建新文件
3. 语法：`echo`
例：`echo "123 456....">f.txt` 将 `123 456....` 写入到 `f.txt` 文件中
4. 语法：`cat`
例：`cat > a.txt` 创建 a. txt 并编辑，按 `ctrl+c` 保存并退出
5. 语法：`vim`
6. 语法：`gedit`
### 排序
语法：`sort`
对文件进行排序
### 去冗
语法：`uniq`
对==排序之后的==文件去重
### 统计
语法：`wc`
用于计算字数，利用 wc 指令可以计算文件的 byte 数、字数、列数，若不指定文件名称或是所给予的文件名为"-"，则 wc 指令会从标准输入设备读取数据
参数：
-c 只显示 bytes 数
-l 显示行数
-w 只显示字数
--version 显示版本信息
结果：`行数 字数 字节数`
### 文件内容比较
1. 语法：`comm`
对==已经排好顺序的==文件进行比较。这项指令会一列一列地比较两个已排序文件的差异，并将其结果显示出来，如果没有指定任何参数，则会把结果分成 3 列显示：第一列仅是在第一个文件中出现过的列，第二列是仅在第二个文件中出现过的列，第三列则是在第一与第二个文件里都出现过的列
2. 语法：`diff`
用于比较文件的差异。diff 以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则 diff 会比较目录中相同文件名的文件，但不会比较其中子目录
### 文件内容查询
语法：`grep`
用于查找文件里符合条件的字符串。用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为-，则 grep 指令会从标准输入设备读取数据

# Shell 基础
## Shell 概述
### 什么是 Shell
+ Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序，用户可以用 Shell 来启动、挂起、停止甚至是编写一些程序
+ Shell 还是一个==功能相当强大的编程语言==，易编写，易调试，灵活性较强
+ Shell 是解释执行的脚本语言，在 Shell 中可以直接调用 Linux 系统命令
### Shell 的分类
+ Bourne Shell：从 1979 年起 Unix 就开始使用 Bourne Shell，Bourne Shell 的主文件名为 sh
+ C Shell: C Shell 主要在 BSD 版的 Unix 系统中使用，其语法和 C 语言相类似而得名
+ Shell 的两种主要语法类型有 Bourne 和 C，==这两种语法彼此不兼容==。Bourne 家族主要包括 sh、ksh、Bash、psh、zsh；C 家族主要包括：csh、tcsh
#### Bash
Bash 与 sh 兼容，现在使用的 Linux 就是使用 Bash 作为用户的基本 Shell
### Linux 支持的 Shell
+ `文件/etc/shells`
支持 sh 和 bash
## 脚本执行方式
### echo 输出命令
`echo [选项] [输出内容]`
选项：
-e 支持反斜线控制的字符转换，前面有斜线的字符将作为转义字符
-n 不换行输出
可以制定内容输出到屏幕
#### echo 控制字符
`\a` 输出警告音
`\b` 退格键，也就是向左删除
`\n` 换行符
`\r` 回车键
`\t` 制表符，Tab 键
`\v` 垂直制表符
`\0nnn` 按八进制 ASCII 码表输出字符，其中 0 为数字 0，nnn 是 3 位八进制数
`\xhh` 按十六进制 ASCII 码表输出字符，其中 hh 是两位十六进制数
#### echo 输出到文件
命令：`echo "字符串" > 文件名`
### 第一个脚本
```shell
vim hello.sh
#新建文件，并进行编辑
#！/bin/bash
#这不是注释，必须要有，表示这是一个Linux的标准脚本
echo Hello World！
#这是输出
```
除了第一句里的 `#`，其他的都是注释
### 脚本执行
第一种：赋予执行权限，直接运行
`chmod 755 hello.sh`
`./hello.sh`
第二种：通过 Bash 调用执行脚本
`bash hello.sh`
## Bash 的基本功能
### 命令别名与快捷键
1. 为什么需要别名?
+ 命令比较长
+ 换版本，命令格式不习惯
2. 命令：`alias`
作用：`显示所有别名`
3. 命令：`alias "别名=原名"`
作用：给原命令起一个别名
4. 别名永久生效与删除别名
命令：`vim ~/.bashrc`
写入环境变量配置文件
命令： `unalias 别名`
删除别名
5. 命令生效顺序
+ 第一顺位用绝对路径执行的内部或相对路径执行的命令
+ 第二顺位执行别名
+ 第三顺位执行Bash的内部命令
+ 第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令
6. 常用快捷键
`ctrl+c` 强制终止当前命令
`ctrl+l` 清屏
`ctrl+a` 光标移动到命令行首
`ctrl+e` 光标移动到命令行尾
`ctrl+u` 从光标所在位置删除到行首
`ctrl+z` 把命令放入后台
`ctrl+r` 在历史命令中搜索
### 历史命令
1. 语法：`history [选项] [历史命令保存文件]`
选项：
-c 清空历史名命令
-w 把缓存中的历史命令写入历史命令保存文件 `~/.bash_history`
2. 历史命令的调用
使用上、下箭头调用以前的历史命令
使用“! n”重复执行第 n 条历史命令
使用“!!”重复执行上一条命令
使用“! 字串”重复执行最后一条以该字串开头的命令
3. 使用 `Tab` 可以自动补全
### 输出重定向
1. 标准输入输出

| 设备   | 设备文件名   | 文件描述符 | 类型 |
| ------ | ------------ | ---------- | ---- |
| 键盘   | `/dev/stdin` |    0        |    标准输入  |
| 显示器 | `/dev/stdout`             |  1          |  标准输出    |
|  显示器      | `/dev/stderr`              |   2         | 标准错误输出     |

2. 输出重定向

| 类型               | 符号           | 作用                                                       |
| ------------------ | -------------- | ---------------------------------------------------------- |
| 标准输出重定向     | 命令>文件      | 以覆盖的方式，把命令的正确输出输出到指定的文件或设备当中   |
| 标准输出重定向     | 命令>>文件     | 以追加的方式，把命令的正确输出输出到指定的文件或设备当中   |
| 标准错误输出重定向 | 错误命令2>文件 | 以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中 |
| 标准错误输出重定向                   | 错误命令 2>>文件               |以追加的方式，把命令的错误输出输出到指定的文件或设备当中                                                            |

3. 输入重定向
命令：`wc [选项] [文件名]`
选项：
-c 统计字节数
-w 统计单词数
-l 统计行数
### 多命令顺序执行
1. 多命令执行符
+ 多命令执行符：`；`  格式：`命令1；命令2`  作用：多个命令顺序执行，命令之间没有任何逻辑联系
+ 多命令执行符：`&&`  格式：`命令1&&命令2`  作用：逻辑与，当命令 1 正确执行，则命令 2 才会执行；当命令 1 执行不正确，则命令 2 不会执行
+ 多命令执行符：`||`  格式：`命令1||命令2`  作用：逻辑或，当命令 1 执行不正确，则命令 2 才会执行；当命令 1 正确执行，则命令 2 不会执行
==注意：==
`；` 管道符：中间出现问题的话，后面的照样运行
`&&` 管道符：只有前面正常运行，后面才会运行
`||` 管道符：只有前面不正常运行，后面才会运行
2. 管道符
命令格式：`命令1||命令2`
作用：命令 1 的正确输出作为命令 2 的操作对象
### Shell 中特殊符号
通配符

| 符号     | 作用                                                             |
| -------- | ---------------------------------------------------------------- |
| `*`      | 匹配任何字符串/文本，包括空字符串；`*`代表任意字符（0 个或多个） |
| `？`     | 匹配任何一个字符（不在括号内时）`？` 代表任意一个字符            |
| `[abcd]` | 匹配 abcd 中任何一个字符                                         |
| `[a—z]`  | 表示范围 a 到 z，表示范围的意思，`[]` 匹配中括号中任意一个字符   |
| `{..}`   | 表示生成序列，以逗号分隔，且不能有空格                           |
| `[！abcd]`         |   或 `[^abcd]` 表示非，表示不匹配括号里面的任何一个字符                                                              |


---
banner: "https://api.dujin.org/bing/1920.php"
cssclass: noyaml,noscroll,myhome
obsidianUIMode: preview
banner_x: 0.5
banner_y: 0.5
---

#数据结构 #C语言 #算法

# 绪论

## 数据结构的研究内容

数据结构是一门研究==非数值计算==的程序设计中计算机的==操作对象==以及它们之间的==关系==和==操作==的学科。
## 基本概念和术语
### 数据、数据元素、数据项、数据对象
+ 数据 (Data)
	+ 能输入计算机且能被计算机处理的==各种符号的集合==
	+ 包括：
		+ 数值型的数据：整数、实数等
		+ 非数值型的数据：文字、图像、图形、声音等
+ 数据元素 (Data element)
	+ 是数据的==基本单位==，在计算机程序中通常作为一个整体进行考虑和处理
	+ 也简称为元素，或称为记录、结点或顶点
	+ 一个数据元素可由若干个==数据项==组成
+ 数据项 (Data item)
	+ 构成数据元素的不可分割的==最小单位==

> 数据、数据元素、数据项三者之间的关系：
> 数据>数据元素>数据项

+ 数据对象 (Data object)
	+ 是性质相同的数据元素的集合，是数据的一个子集

> 数据元素与数据对象的区别?
> 
> 数据元素——组成数据的基本单位, 与数据的关系是集合的个体
> 数据对象——性质相同的数据元素的集合, 与数据的关系是：集合的子集

### 数据结构

数据结构 (Data structure)
+ 数据元素不是孤立存在的，它们之间存在着某种关系，数据元素相互之间的关系称为结构 (structure)
+ 是指相互之间存在一种或多种特定关系的数据元素集合
+ 或者说，数据结构是带结构的数据元素的集合

包括以下三个方面内容：
+ 数据元素之间的逻辑关系，也称为==逻辑结构==
+ 数据元素及其关系在计算机内存中的表示 (又称为映像)，称为数据的==物理结构==或数据的==存储结构==
+ 数据的==运算和实现==，即对数据元素可以施加的操作以及这些操作在相应的存储结构上的实现

两个层次：
+ 逻辑结构
	+ 描述数据元素之间的逻辑关系
	+ 与数据的存储无关，独立于计算机
	+ 是从具体问题抽象出来的数学模型
+ 物理结构 (存储结构)
	+ 数据元素及其关系在计算机存储器中的结构 (存储方式)
	+ 是数据结构在计算机中的表示

> 逻辑结构与存储结构的关系：
> 1. 存储结构是逻辑关系的映像与元素本身的映像
> 2. 逻辑结构是数据结构的抽象，存储结构是数据结构的实现
> 3. 两者综合起来建立了数据元素之间的结构关系

#### 逻辑结构的种类
1. 线性结构
有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前趋和一个直接后继。
例如：线性表、栈、队列、串
2. 非线性结构
一个结点可能有多个直接前趋和直接后继。
例如：树、图
#### 存储结构的种类
+ 顺序存储结构
	+ 用一组连续的存储单元依次存储数据元素，数据元素之间的逻辑关系由元素的存储位置来表示
	+ C 语言中用数组来实现顺序存储结构
+ 链接存储结构
	+ 用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来表示
	+ C 语言中用指针来实现链式存储结构
+ 索引存储结构
	+ 在存储结点信息的同时，还建立附加的索引表
+ 散列存储结构
	+ 根据结点的关键字直接计算出该结点的存储地址
### 数据类型和抽象数据类型

在使用高级程序设计语言编写程序时，必须对程序中出现的每个变量、常量、或表达式，明确说明它们所属的数据类型。

#### 数据类型 (Data Type)
定义：数据类型是一组性质相同的值的集合以及定义于这个值集合上的一组操作的总称。
>数据类型=值的集合+值集合上的一组操作
#### 抽象数据类型 (Abstract Data Type, ADT)

定义：是指一个数学模型以及定义在此数学模型上的一组数据。
+ 由用户定义，从问题抽象出==数据模型==(逻辑结构)
+ 还包括定义在数据模型上的一组==抽象运算==(相关操作)
+ 不考虑计算机内的具体存储结构与运算的具体实现算法

抽象数据类型的形式定义

>抽象数据类型可用 (D, S, P) 三元组表示
其中：
D 是数据对象；
S 是 D 上的关系集；
P 是 D 的基本操作集。

定义格式：

>ADT 抽象数据类型名{
>数据对象：<数据对象的定义>
>数据关系：<数据关系的定义>
>基本操作：<基本操作的定义>
>}ADT 抽象数据类型名

其中：
+ 数据对象、数据关系的定义用伪代码描述
+ 基本操作的定义格式为：
	+ 基本操作名 (参数表)
	+ 初始条件：<初始条件描述>
	+ 操作结果：<操作结果描述>
+ 基本操作定义格式说明：
	+ 参数表：
		1. 赋值参数只为操作提供输入值
		2. 引用参数以 `&` 打头，除可提供输入值外，还将返回操作结果 
	+ 初始条件：描述操作执行之前数据结构和参数应满足的条件，若不满足，则操作失败，并返回相应出错信息。若初始条件为空，则省略之
	+ 操作结果：说明操作正常完成之后，数据结构的变化状况和应返回的结果

例：Circle 的定义
```ADT
ADT Circle{
	数据对象:D={r,x,y|r,x,y均为实数}
	数据关系:R={<r,x,y>|r是半径,<x,y>是圆心坐标}
	基本操作:
	Circle(&C,r,x,y)
			操作结果:构造一个圆
	double Area(C)
			初始条件:圆已存在
			操作结果:计算面积
	double Circumference(C)
			初始条件:圆已经存在
			操作结果:计算周长
		······
}ADT Circle
```

##### 抽象数据类型的表示与实现

C 语言实现抽象数据类型：
+ 用已有数据类型定义描述它的存储结构
+ 用函数定义描述它的操作

### 小结
![](https://obsidian-picture.oss-cn-qingdao.aliyuncs.com/my-img/数据结构1.png)

## 算法和算法分析

### 算法 (Algorithm)

定义：对特定问题求解方法和步骤的一种描述，它是指令的有限序列。其中每个指令表示一个或多个操作。

算法的描述：
+ 自然语言：英语、中文
+ 流程图
+ 伪代码
+ 程序代码

> 算法与程序的区别是什么？
> 算法是解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有多种算法
> 程序是用某种程序设计语言对算法的具体实现

>程序=数据结构+算法
>数据结构通过算法实现操作
>算法根据数据结构设计程序

算法特性：
+ 有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成
+ 确定性：算法中的每一条指令必须有确切的含义，没有二义性，在任何条件下，只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出
+ 可行性：算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现
+ 输入：一个算法有零个或多个输入
+ 输出：一个算法有一个或多个输出

算法设计的要求：
+ 正确性 (Correctness)
+ 可读性 (Readability)
+ 健壮性 (Robustness)(鲁棒性)
+ 高效性 (Efficiency)

### 算法分析

* 空间复杂度 S (n)——根据算法写成的程序在执行时==占用存储单元的长度。==
* 时间复杂度 T (n)——根据算法写成的程序在执行时==耗费时间的长度。====

算法时间复杂度：
+ 算法中重复执行次数和算法的执行时间成正比的语句，对算法运行时间的贡献最大，执行次数最多
+ 一般总考虑在最坏情况下的时间复杂度

分析算法时间复杂度的基本方法：
+ 定理 1.1
	+ 若 f (n)= $a_mn^m+a_{m-1}n^{m-1}···+a_1n+a_0$ 是 m 次多项式，则 T (n)=O ($n^m$)。

1. 找出==语句频度最大==的那条语句作为==基本语句==
2. 计算==基本语句==的频度得到问题规模 n 的某个函数 f (n)
3. 取其数量级用符号"O"表示

时间复杂度 T (n) 按数量级递增顺序为：常数阶 O (1)<对数阶 O ($\log_2n$ )<线性阶 O (n)<线性对数阶 O ($n\log_2n$ )<平方阶 O ($n^2$)<立方阶 O ($n^3$)<k 次方阶 O ($n^k$)<指数阶 O ($2^n$)
# 线性表

## 定义和特点
线性表是具有==相同特性==的数据元素的一个==有限序列==
（$a_1,a_2,...,a_{i-1},a_i,...,a_n$）
+ 其中 $a_1$ 是线性起点，也叫起始结点，$a_{i-1}$ 是 $a_i$ 的直接前趋，$a_{i+1}$ 是 $a_i$ 的直接后继，$a_n$ 是线性终点，也叫终端结点。
+ 1，2，3···n 叫做下标，是元素的序号，表示元素在表中的位置，n 为元素总个数，即表长，n=0 时称为空表。
线性表 (Linear List)：由==n (n>=0) 个==数据元素 (结点) $a_1,a_2,...,a_{i-1},a_i,...,a_n$ 组成的==有限序列==
+ 其中数据元素的个数 n 定义为表的长度
+ 当 n=0 时称为空表
+ 将非空的线性表 (n>0) 记作：($a_1,a_2,...,a_{i-1},a_i,...,a_n$)
+ 这里的数据元素 $a_i$ (1<=i<=n) 只是一个抽象的符号，其具体含义在不同的情况下可以不同
## 线性表的类型定义
抽象数据类型线性表的定义：
```ADT
ADT List{
	数据对象:D={ai|ai属于Elemset,(i=1,2,···,n,n>=0)}
	数据关系:R={<ai-1,ai>|ai-1,ai属于D,(i=2,3,···,n)}
	基本操作:
	InitList(&L);    DestoryList(&L);
	等
}ADT List
```
## 线性表的基本操作
初始化：InitList (&L)  (Initialization List) 
+ 操作结果：构造一个空的线性表 L
销毁：DestroyList (&L)  
+ 初始条件：线性表 L 已经存在
+ 操作结果：销毁线性表 L
清除：ClearList (&L)  
+ 初始条件：线性表 L 已经存在
+ 操作结果：将线性表 L 重置为空表
判断是否为空表：ListEmpty (L) 
+ 初始条件：线性表 L 已经存在
+ 操作结果：若线性表 L 为空表，则返回 TRUE; 否则返回 FALSE
求线性表长度：ListLength (L)
+ 初始条件：线性表 L 已经存在
+ 操作结果：返回线性表 L 中的数据元素个数
获取元素：GetElem (L, I,&e)
+ 初始条件: 线性表 L 已经存在，1<=i<=ListLength (L)
+ 操作结果：用 e 返回线性表 L 中第 i 个数据元素的值
查找定位：LocateElem (L, e, compare ())
+ 初始条件：线性表 L 已经存在，compare () 是数据元素判定函数
+ 操作结果：返回 L 中第 1 个与 e 满足 compare () 的数据元素的位序。若这样的数据元素不存在则返回值为 0
求一个元素的前趋：PriorElem (L, cur_ e,&pre_e)
+ 初始条件：线性表 L 已经存在
+ 操作结果：若 cur_e 是 L 的数据元素，且不是第一个，则用 pre_e 返回它的前趋，否则操作失败，pre_e 无意义
求一个元素的后继：NextElem (L, cur_e,&next_e)
+ 初始条件：线性表 L 已经存在
+ 操作结果：若 cur_e 是 L 的数据元素，且不是第最后个，则用 next_e 返回它的后继，否则操作失败，next_e 无意义
插入一个元素：ListInsert (&L, i, e)
+ 初始条件：线性表 L 已经存在，1<=i<=ListLength (L)+1
+ 操作结果：在 L 的第 i 个位置之前插入新的数据元素 e，L 的长度加一
删除第 i 个元素：ListDelete (&L, i,&e)
+ 初始条件：线性表 L 已经存在，1<=i<=ListLength (L)
+ 操作结果：删除 L 的第 i 个数据元素，并用 e 返回其值，L 的长度减一
遍历：ListTraverse (&L, visited ())
+ 初始条件：线性表 L 已经存在
+ 操作结果：依次对线性表中每个元素调用 visited ()

## 线性表的存储结构
两种存储结构：顺序存储结构和链式存储结构

### 线性表的顺序存储表示
线性表的顺序表示又称为==顺序存储结构==或==顺序映像==

顺序存储定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。
线性表：（$a_1,a_2,···,a_{i-1},a_i,a_{i+1},···,a_n$）
线性表的第一个数据元素 $a_1$ 的存储位置，称作线性表的起始位置或基地址。

> 简言之，逻辑上相邻，物理上也相邻

注意：线性表顺序存储结构==占用一片连续的存储空间==。知道某个元素的存储位置就可以计算其他元素的存储位置。

顺序表的特点：
1. ==以物理位置相邻表示逻辑关系, 地址是连续的。==
2. ==任意元素均可随机存取。(优点)==
3. ==依次存放各个元素==
4. ==各个元素类型相同==

因此我们可以用一维数组来表示顺序表。
但线性表的表长是可变的。而数组长度是不可以动态定义的。(即 C 语言中不允许对数组的大小作动态定义)。我们再用一个变量来表示顺序表的长度属性。

```类c
#define LIST_INIT_SIZE 100 //线性表存储空间的初始分配量
typedef struct
{
	ElemType elem[LIST_INIT_SZE];//ElemType指数据类型
	int length;//当前长度
}SqList;
```






# 排序算法
十大经典排序算法
+ 冒泡排序
+ 选择排序
+ 插入排序
+ 希尔排序
+ 快速排序
+ 归并排序
+ 堆排序
+ 计数排序
+ 基数排序
+ 桶排序
## 冒泡排序

基于交换的排序，每一轮将序列中的最大 (小) 值放到序列的尾部。

基本原理：对存放原始数据的数组，按从前往后的方向进行多次扫描，每一次扫描称为一趟，当发现相邻两个数据的次序与排序要求的大小次序不符合时，即将这两个数据进行交换。

时间复杂度：O ($n^2$)

演示：
![](https://obsidian-picture.oss-cn-qingdao.aliyuncs.com/my-img/数据结构2.gif)

代码实现：
```c
void bubble_sort(int arr[], int length)
{
	//外层循环：逐趟扫描
	//i>1的原因：只有一个元素的数组自然有序
	for (int i = length; i > 1; i--)
	{
		int swappedFlag = 0;//是否发生了交换的标志
		//一趟扫描
		for (int j = 0; j < i - 1; j++)
		{
			if (arr[j + 1] < arr[j])
			{
				int temp = arr[j + 1];
				arr[j + 1] = arr[j];
				arr[j] = temp;
				swappedFlag = 1;
			}
		}
		if (!swappedFlag)
			break;//若无交换发生，结束
	}
}
```


## 选择排序

首先在未排序序列中找到最小 (大) 元素，存放到排序序列的起始位置，再从剩余未排序元素中继续寻找最小 (大) 元素，然后放到已排序序列的末尾，重复进行，直到所有元素均排序完毕。

时间复杂度：O ($n^2$)

演示：
![](https://obsidian-picture.oss-cn-qingdao.aliyuncs.com/my-img/数据结构3.gif)

代码实现：

```c
void selection_sort(int arr[], int length)
{
	int i, j, min;//min用于表示最小值的下标
	for (i = 0; i < length; i++)
	{
		min = i;
		//找到最小值
		for (j = i + 1; j < length; j++)
		{
			if (arr[j] < arr[min])
				min = j;
		}
		//将最小值与第一个元素交换
		int temp = arr[min];
		arr[min] = arr[i];
		arr[i] = temp;
	}
}
```